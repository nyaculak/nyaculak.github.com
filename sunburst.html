<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>Sunburst</title>
</head>
<body>
  <div id="infobox">
    <div id="title">
      <h1>Common Core Standard Alignment Tool</h1>
    </div>
    <div id="standard">
      <div class="label">Standard</div> <div class="updateable">Here</div>
    </div>
    <div id="cw1">
      <div class="label">CW1</div> <div class="updateable">Here</div>
    </div>
    <div id="cw2">
      <div class="label">CW2</div> <div class="updateable">Here</div>
    </div>
  </div>
  <style>
    h1 {
      margin-bottom: 0;
    }
    body {
      text-align:center;
    }
    #infobox div {
      margin: 2px;
    }
    .label {
      font-weight: bold;
    }
    .updateable { min-height: 36px; }
    path:hover {
      opacity: .5;
    }
  </style>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
  <script>
    var CHILD_PRED = "http://purl.org/gem/qualifiers/hasChild",
        ID_PRED = "http://purl.org/ASN/schema/core/identifier",
        HIDDEN_CHILD_PRED = "_http://purl.org/gem/qualifiers/hasChild",
        DESCR_PRED = "http://purl.org/dc/terms/description",
        ROOT_NAME = "http://asn.jesandco.org/resources/D10003FB",
        ROOT_NAME_T1 = "http://asn.jesandco.org/resources/D10003B9",
        ROOT_NAME_T2 = "http://asn.jesandco.org/resources/D100029D",
        TARGET_URI = "subjectURI",
        SUBJECT_URI = "objectURI";

    var t1_s1, t2_s1,
        i = 0,
        width  = 400, // 600
        height = 400,
        radius = Math.min(width, height) / 2;

    var x = d3.scale.linear().range([0, 2 * Math.PI]),
        y = d3.scale.sqrt().range([0, radius]);

    var text = d3.select("#standard").select(".updateable"),
        crosswalk1 = d3.select("#cw1").select(".updateable"),
        crosswalk2 = d3.select("#cw2").select(".updateable");

    var mastersvg = d3.select("body").append("svg")
      .attr("width", width * 3 + 20 + 20)
      .attr("height", height + 20)
      .attr("margin", "0 auto");

    var svg = mastersvg.append("g")
          .attr("transform", "translate(" + (width / 2 + 10) + "," + (height / 2 + 10) + ")"),
        svg2 = mastersvg.append("g")
          .attr("transform", "translate(" + (3 * width / 2 + 20) + "," + (height / 2 + 10) + ")"),
        svg3 = mastersvg.append("g")
          .attr("transform", "translate(" + (5 * width / 2 + 30) + "," + (height / 2 + 10) + ")");

    var arc = d3.svg.arc()
      .startAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x))); })
      .endAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); })
      .innerRadius(function(d) { return Math.max(0, y(d.y)); })
      .outerRadius(function(d) { return Math.max(0, y(d.y + d.dy)); });

    var sunburst_s1 = { "partition" : d3.layout.partition().sort(null).value(function(d) {return 1;}),
                        "data"      : null,
                        "root"      : null,
                        "paths"     : null },
        sunburst_t1 = { "partition" : d3.layout.partition().sort(null).value(function(d) {return 1;}),
                        "data"      : null,
                        "root"      : null,
                        "paths"     : null },
        sunburst_t2 = { "partition" : d3.layout.partition().sort(null).value(function(d) {return 1;}),
                        "data"      : null,
                        "root"      : null,
                        "paths"     : null };

    d3.json("/data/s1.json", function(error, json) {
      d3.json("/data/t1.json", function(error2, json2) {
        d3.json("/data/t2.json", function(error3, json3) {
          d3.csv("/data/t1-s1.csv", function(cw) {
            d3.csv("/data/t2-s1.csv", function(cw2) {
              if(error || error2 || error3) throw error;
              sunburst_s1.data = json;  sunburst_s1.root = json[ROOT_NAME];
              sunburst_t1.data = json2; sunburst_t1.root = json2[ROOT_NAME_T1];
              sunburst_t2.data = json3; sunburst_t2.root = json3[ROOT_NAME_T2];

              var map = {};

              cw.forEach(function(d) {
                map[d[TARGET_URI].slice(-8)] = d[SUBJECT_URI].slice(-8);
                map[d[SUBJECT_URI].slice(-8)] = d[TARGET_URI].slice(-8);
              });
              t1_s1 = map;

              map = {};
              cw2.forEach(function(d) {
                map[d[TARGET_URI].slice(-8)] = d[SUBJECT_URI].slice(-8);
                map[d[SUBJECT_URI].slice(-8)] = d[TARGET_URI].slice(-8);
              });
              t2_s1 = map;

              render();
            });
          });
        });
      });
    });

    function toggle(sunburst) {
      return function (d) {
        // remove children of clicked node
        var buf = d._children;
        d._children = d.children;
        d.children = buf;

        // compute the new layout
        var old_d = {x: d.x, dx: d.dx, y: d.y, dy: d.dy};
        var new_nodes = sunburst.partition.nodes(sunburst.root);

        // update the removed children to have 0 area put occupy the correct position
        // add the children back into the nodes of the computed layout
        if (d._children)
          d._children.forEach(function (node) { walkTree(node, function (x) {
            x.x = d.x + d.dx / 2.;
            x.dx = 0;
            x.y = d.y + d.dy;

            new_nodes.push(x);
          });});

        if (d.children)
          d.children.forEach(function (node) { walkTree(node, function(x) {
            x.x0 = old_d.x + old_d.dx / 2.;
            x.dx0 = 0;
            x.y0 = old_d.y + old_d.dy;
          });});

        // apply transition
        sunburst.paths
            .data(new_nodes, function(d) { return d.id || (d.id = ++i); })
            .attr("display", function(d) { return d.depth == 0 ? "none" : null;})
          .transition()
            .duration(450)
            .ease("cubic-in-out")
            .attrTween("d", arcTweenData)
            .attrTween("display", function (d, i) {
              return d.depth == 0
                  ? function (t) { return "none"; }
                  : function (t) { return t == 1 && d.dx == 0 ? "none" : null; };
            });
      }
    }

    function findPathTo(root, node_id, path) {
      if (id(root) === node_id){
        path.unshift(root);
        return true;
      }

      if (root.children) {
        for (i in root.children)
          if (findPathTo(root.children[i], node_id, path)) {
            path.unshift(root);
            return true;
          }

      } else if (root._children) {
        for(i in root._children) {
          if (findPathTo(root._children[i], node_id, path)) {
              path.unshift(root);
              return true;
          }
        }
      }

      return false;
    }

    function showCrosswalk(sunburst) {
      return function (node_id) {
        var nodes = [];
        var index = null;
        findPathTo(sunburst.root, node_id, nodes);

        for (i in nodes) {
          if (nodes[i]._children) {
            if (!index) index = i;
            else {
              nodes[i].children = nodes[i]._children;
              nodes[i]._children = null;
            }
          }
        }

        toggle(sunburst)(nodes[index]);
        sunburst.path.style("opacity", 0.1);
        sunburst.path.data(nodes, function(d) { return d.id || (d.id = ++i); }).style("opacity", 1);
      }
    }

    function render() {
      var nodes,
          color = d3.scale.category20c();

      function getColor(d) {
        return color((d.children || d._children ? d : d.parent).id);
      }

      nodes = sunburst_t1.partition.children(children(sunburst_t1)).nodes(sunburst_t1.root);
      collapse(nodes[0], 2);
      sunburst_t1.partition.children(function(d) {return d.children;}).nodes(sunburst_t1.root);

      sunburst_t1.paths = svg.selectAll("path").data(nodes, function(d) { return d.id || (d.id = ++i); });
      sunburst_t1.paths.enter().append("path")
        .attr("d", arc)
        .attr("display", function(d) { return d.depth == 0 || d.dx == 0 ? "none" : null; }) // hide inner ring
        .attr("fill", function(d) { return id(d) in t1_s1 ? "#DB18DB" : getColor(d); })
        .attr("stroke", "#fff")
        .on('mouseover', function(d) { if (d.depth != null) text.text(d[DESCR_PRED][0].value); })
        .on('mouseout',  function(d) { text.text("");})
        .on('click', toggle(sunburst_t1))
        .each(stash);

      nodes = sunburst_s1.partition.children(children(sunburst_s1)).nodes(sunburst_s1.root);
      collapse(nodes[0], 1);
      sunburst_s1.partition.children(function(d){return d.children;}).nodes(sunburst_s1.root);

      sunburst_s1.paths = svg2.selectAll("path").data(nodes, function(d) { return d.id || (d.id = ++i); });
      sunburst_s1.paths.enter().append("path")
        .attr("d", arc)
        .attr("display", function(d) { return d.depth == 0 || d.dx == 0 ? "none" : null; }) // hide inner ring
        .style("fill", function(d) { return id(d) in t1_s1 || id(d) in t2_s1 ? "#DB18DB" : getColor(d); })
        .style("stroke", "#fff")
        .on('mouseover', function(d) { if (d.depth != null) text.text(d[DESCR_PRED][0].value); })
        .on('mouseout',  function(d) { text.text("");})
        .on('click', toggle(sunburst_s1))
        .each(stash);

      nodes = sunburst_t2.partition.children(children(sunburst_t2)).nodes(sunburst_t2.root);
      collapse(nodes[0], 1);
      sunburst_t2.partition.children(function(d){return d.children}).nodes(sunburst_t2.root);

      sunburst_t2.paths = svg3.selectAll("path").data(nodes, function(d) { return d.id || (d.id = ++i); });
      sunburst_t2.paths.enter().append("path")
        .attr("d", arc)
        .attr("display", function(d) { return d.depth == 0 || d.dx == 0 ? "none" : null; }) // hide inner ring
        .style("fill", function(d) { return id(d) in t2_s1 ? "#DB18DB" : getColor(d); })
        .style("stroke", "#fff")
        .on('mouseover', function(d) { if (d.depth != null) text.text(d[DESCR_PRED][0].value); })
        .on('mouseout',  function(d) { text.text("");})
        .on('click', toggle(sunburst_t2))
        .each(stash);
    }

    // Helper functions ////////////////////////////////////////////////////////
    // minimizes all the nodes at the specified depth
    function collapse(tree, depth) {
      walkTree(tree, function(d) {
        if (d.depth == depth) {
          d._children = d.children;
          d.children  = null;
        }
        if (d.depth > depth) {
          d.dx = 0;
        }
      });
    }

    function id(d) { return d[ID_PRED] ? d[ID_PRED][0].value.slice(-8) : ""; }

    // specifies how to retrieve children from the json
    function children(sunburst) {
      return function (d) {
        var children = [];
        if (d[CHILD_PRED]) {
          d[CHILD_PRED].forEach(function (x){children.push(sunburst.data[x.value]);});
        }
        return children;
      }
    }

    // applies a function to the entire tree
    function walkTree(d, f) {
      if (d.children)
        d.children.forEach(function (x) { walkTree(x, f); });
      f(d);
    }

    // setup for switching data: stash the old values for transition.
    function stash(d) {
      d.x0  = d.x;
      d.dx0 = d.dx;
      d.y0  = d.y;
      d.dy0 = d.dy;
    }

    // interpolate the arcs in data space for the transitions
    function arcTweenData(a, i) {
      var oi = d3.interpolate({x: a.x0, dx: a.dx0, y: a.y0, dy: a.dy0}, a);

      return function (t) {
        var b = oi(t);
        a.x0  = b.x;
        a.dx0 = b.dx;
        a.y0  = b.y;
        a.dy0 = b.dy;
        return arc(b);
      }
    }
  </script>
</body>
</html>
