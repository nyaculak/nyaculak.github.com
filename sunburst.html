<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>Sunburst</title>
</head>
<body>
  <div id="infobox">
    <div id="title">
      <h1>Common Core Standard Alignment Tool</h1>
    </div>
    <div id="standard">
      <div class="label">Standard</div> <div class="updateable">Here</div>
    </div>
    <div id="cw1">
      <div class="label">CW1</div> <div class="updateable">Here</div>
    </div>
    <div id="cw2">
      <div class="label">CW2</div> <div class="updateable">Here</div>
    </div>
  </div>
  <style>
    h1 {
      margin-bottom: 0;
    }
    body {
      text-align:center;
    }
    #infobox div {
      margin: 2px;
    }
    .label {
      font-weight: bold;
    }
    .updateable { min-height: 36px; }
    path:hover {
      opacity: .5;
    }
  </style>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
  <script>
    var CHILD_PRED = "http://purl.org/gem/qualifiers/hasChild",
        ID_PRED = "http://purl.org/ASN/schema/core/identifier",
        HIDDEN_CHILD_PRED = "_http://purl.org/gem/qualifiers/hasChild",
        DESCR_PRED = "http://purl.org/dc/terms/description",
        ROOT_NAME = "http://asn.jesandco.org/resources/D10003FB",
        ROOT_NAME_T1 = "http://asn.jesandco.org/resources/D10003B9",
        ROOT_NAME_T2 = "http://asn.jesandco.org/resources/D100029D",
        TARGET_URI = "subjectURI",
        SUBJECT_URI = "objectURI";

    var t1_s1, t2_s1,
        i = 0,
        width  = 400, // 600
        height = 400,
        radius = Math.min(width, height) / 2;

    var x = d3.scale.linear().range([0, 2 * Math.PI]),
        y = d3.scale.sqrt().range([0, radius]);

    var text = d3.select("#standard").select(".updateable"),
        crosswalk1 = d3.select("#cw1").select(".updateable"),
        crosswalk2 = d3.select("#cw2").select(".updateable");

    var mastersvg = d3.select("body").append("svg")
      .attr("width", width * 3 + 20 + 20)
      .attr("height", height + 20)
      .attr("margin", "0 auto");

    var svg = mastersvg.append("g")
          .attr("transform", "translate(" + (width / 2 + 10) + "," + (height / 2 + 10) + ")"),
        svg2 = mastersvg.append("g")
          .attr("transform", "translate(" + (3 * width / 2 + 20) + "," + (height / 2 + 10) + ")"),
        svg3 = mastersvg.append("g")
          .attr("transform", "translate(" + (5 * width / 2 + 30) + "," + (height / 2 + 10) + ")");

    var arc = d3.svg.arc()
      .startAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x))); })
      .endAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); })
      .innerRadius(function(d) { return Math.max(0, y(d.y)); })
      .outerRadius(function(d) { return Math.max(0, y(d.y + d.dy)); });

    var sunburst_s1 = { "partition" : d3.layout.partition().sort(null).value(function(d) {return 1;}),
                        "data"      : null,
                        "root"      : null,
                        "paths"     : null },
        sunburst_t1 = { "partition" : d3.layout.partition().sort(null).value(function(d) {return 1;}),
                        "data"      : null,
                        "root"      : null,
                        "paths"     : null },
        sunburst_t2 = { "partition" : d3.layout.partition().sort(null).value(function(d) {return 1;}),
                        "data"      : null,
                        "root"      : null,
                        "paths"     : null };

    d3.json("/data/s1.json", function(error, json) {
      d3.json("/data/t1.json", function(error2, json2) {
        d3.json("/data/t2.json", function(error3, json3) {
          d3.csv("/data/t1-s1.csv", function(cw) {
            d3.csv("/data/t2-s1.csv", function(cw2) {
              if(error || error2 || error3) throw error;
              sunburst_s1.data = json;  sunburst_s1.root = json[ROOT_NAME];
              sunburst_t1.data = json2; sunburst_t1.root = json2[ROOT_NAME_T1];
              sunburst_t2.data = json3; sunburst_t2.root = json3[ROOT_NAME_T2];

              var map = {};

              cw.forEach(function(d) {
                if(map[d[TARGET_URI].slice(-8)]) {
                  map[d[TARGET_URI].slice(-8)].push(sunburst_s1.data[d[SUBJECT_URI]]);
                } else {
                  map[d[TARGET_URI].slice(-8)] = [];
                  map[d[TARGET_URI].slice(-8)].push(sunburst_s1.data[d[SUBJECT_URI]]);
                }
                if(map[d[SUBJECT_URI].slice(-8)]) {
                  map[d[SUBJECT_URI].slice(-8)].push(sunburst_t1.data[d[TARGET_URI]]);
                } else {
                  map[d[SUBJECT_URI].slice(-8)] = [];
                  map[d[SUBJECT_URI].slice(-8)].push(sunburst_t1.data[d[TARGET_URI]]);
                }
              });
              t1_s1 = map;

              map = {};
              cw2.forEach(function(d) {
                if(map[d[TARGET_URI].slice(-8)]) {
                  map[d[TARGET_URI].slice(-8)].push(sunburst_s1.data[d[SUBJECT_URI]]);
                } else {
                  map[d[TARGET_URI].slice(-8)] = [];
                  map[d[TARGET_URI].slice(-8)].push(sunburst_s1.data[d[SUBJECT_URI]]);
                }
                if(map[d[SUBJECT_URI].slice(-8)]) {
                  map[d[SUBJECT_URI].slice(-8)].push(sunburst_t2.data[d[TARGET_URI]]);
                } else {
                  map[d[SUBJECT_URI].slice(-8)] = [];
                  map[d[SUBJECT_URI].slice(-8)].push(sunburst_t2.data[d[TARGET_URI]]);
                }
              });
              t2_s1 = map;

              render();
            });
          });
        });
      });
    });

    function transition(sunburst, d) {
      // compute the new layout
      var old_d = {x: d.x, dx: d.dx, y: d.y, dy: d.dy};
      var new_nodes = sunburst.partition.nodes(sunburst.root);

      // update the removed children to have 0 area put occupy the correct position
      // add the children back into the nodes of the computed layout
      if (d._children)
        d._children.forEach(function (node) { walkTree(node, function (x) {
          x.x = d.x + d.dx / 2.;
          x.dx = 0;
          x.y = d.y + d.dy;

          new_nodes.push(x);
        });});

      if (d.children)
        d.children.forEach(function (node) { walkTree(node, function(x) {
          x.x0 = old_d.x + old_d.dx / 2.;
          x.dx0 = 0;
          x.y0 = old_d.y + old_d.dy;
        });});

      // apply transition
      sunburst.paths
          .data(new_nodes, function(d) { return d.id || (d.id = ++i); })
          .attr("display", function(d) { return d.depth == 0 ? "none" : null;})
        .transition()
          .duration(450)
          .ease("cubic-in-out")
          .attrTween("d", arcTweenData)
          .attrTween("display", function (d, i) {
            return d.depth == 0
                ? function (t) { return "none"; }
                : function (t) { return t == 1 && d.dx == 0 ? "none" : null; };
          });
    }

    function toggle(sunburst) {
      return function (d) {
        // remove children of clicked node
        var buf = d._children;
        d._children = d.children;
        d.children = buf;

        transition(sunburst, d);
      }
    }


    function hideCrosswalk(sunburst, d) {
      timeout_ids.forEach(function(d) { clearTimeout(d); });
      timeout_ids = [];
      var node = d.parent,
          nodes = [],
          lowest_marked_node;

      while (node.parent) {
        if (node.marked) {
          node.marked = null;
          node._children = node.children;
          node.children = null;
          lowest_marked_node = node;

          node._children.forEach(function (node) { walkTree(node, function (x) {
            nodes.push(x);
          });});
        }
        node = node.parent;
      }

      var new_nodes = sunburst.partition.nodes(sunburst.root);

      nodes.forEach(function(d) {
        d.x = lowest_marked_node.x + lowest_marked_node.dx / 2.;
        d.dx = 0;
        d.y = lowest_marked_node.y + lowest_marked_node.dy;
      });

      new_nodes = new_nodes.concat(nodes);

      sunburst.paths
          .data(new_nodes, function(d) { return d.id || (d.id = ++i); })
          .attr("display", function(d) { return d.depth == 0 ? "none" : null;})
        .transition()
          .duration(450)
          .ease("cubic-in-out")
          .attrTween("d", arcTweenData)
          .attrTween("opacity", function(d) {
              var x = d3.interpolate(d.opacity, 1);
              d.opacity = 1;
              return function(t) { return x(t); };
          })
          .attrTween("display", function (d, i) {
            return d.depth == 0
                ? function (t) { return "none"; }
                : function (t) { return t == 1 && d.dx == 0 ? "none" : null; };
          });
    }
    function hideCrosswalks(sunburst, data) {
      for(i = 0; i < data.length; i++) {
        hideCrosswalk(sunburst, data[i]);
      }
    }
    var timeout_ids = [];
    function showCrosswalk(sunburst, d) {
      timeout_ids.push(setTimeout(function() {
        var node = d.parent,
            nodes = [d],
            lowest_collapsed_node;

        while (node.parent) {
          if (node._children) {
            node.marked = true;
            node.children = node._children;
            node._children = null;
            lowest_collapsed_node = node;
          }

          nodes.push(node);
          node = node.parent;
        }

        var paths = sunburst.paths;

        if (lowest_collapsed_node)
          var old_d = {x: lowest_collapsed_node.x, dx: lowest_collapsed_node.dx,
                       y: lowest_collapsed_node.y, dy: lowest_collapsed_node.dy};

        var new_nodes = sunburst.partition.nodes(sunburst.root);

        if (lowest_collapsed_node) {
          lowest_collapsed_node.children.forEach(function (node) { walkTree(node, function(x) {
            x.x0 = old_d.x + old_d.dx / 2.;
            x.dx0 = 0;
            x.y0 = old_d.y + old_d.dy;
          });});
        }

        nodes.forEach(function(d) {d.opacity = 1;});

        sunburst.paths
            .data(new_nodes, function(d) { return d.id || (d.id = ++i); })
          .transition()
            .attr("display", function(d) { return d.depth == 0 ? "none" : null;})
            .duration(450)
            .ease("cubic-in-out")
            .attrTween("d", arcTweenData)
            .attrTween("display", function (d, i) {
              return d.depth == 0
                  ? function (t) { return "none"; }
                  : function (t) { return t == 1 && d.dx == 0 ? "none" : null; };
            })
            .filter(function(d) {return nodes.indexOf(d) < 0})
            .duration(450)
            .ease("cubic-in-out")
            .attrTween("opacity", function(d) {
                var x = d3.interpolate(1, 0.1);
                return function(t) {return d.opacity = x(t);};
            });

      }, 500));
    }
    function showCrosswalks(sunburst, data) {
      for(i = 0; i < data.length; i++) {
        showCrosswalk(sunburst, data[i]);
      }
    }

    function render() {
      var nodes,
          color = d3.scale.category20c();

      function getColor(d) {
        return color((d.children || d._children ? d : d.parent).id);
      }

      nodes = sunburst_t1.partition.children(children(sunburst_t1)).nodes(sunburst_t1.root);
      collapse(nodes[0], 2);
      sunburst_t1.partition.children(function(d) {return d.children;}).nodes(sunburst_t1.root);

      sunburst_t1.paths = svg.selectAll("path").data(nodes, function(d) { return d.id || (d.id = ++i); });
      sunburst_t1.paths.enter().append("path")
        .attr("d", arc)
        .attr("display", function(d) { return d.depth == 0 || d.dx == 0 ? "none" : null; }) // hide inner ring
        .attr("fill", function(d) { return id(d) in t1_s1 ? "#DB18DB" : getColor(d); })
        .attr("stroke", "#fff")
        .on('mouseover', function(d) {
          if (d.depth != null) text.text(d[DESCR_PRED][0].value);
          if (id(d) in t1_s1) showCrosswalks(sunburst_s1, t1_s1[id(d)]);
        })
        .on('mouseout',  function(d) {if (id(d) in t1_s1) hideCrosswalks(sunburst_s1, t1_s1[id(d)]);})
        .on('click', toggle(sunburst_t1))
        .each(stash);

      nodes = sunburst_s1.partition.children(children(sunburst_s1)).nodes(sunburst_s1.root);
      collapse(nodes[0], 1);
      sunburst_s1.partition.children(function(d){return d.children;}).nodes(sunburst_s1.root);

      sunburst_s1.paths = svg2.selectAll("path").data(nodes, function(d) { return d.id || (d.id = ++i); });
      sunburst_s1.paths.enter().append("path")
        .attr("d", arc)
        .attr("display", function(d) { return d.depth == 0 || d.dx == 0 ? "none" : null; }) // hide inner ring
        .style("fill", function(d) { return id(d) in t1_s1 || id(d) in t2_s1 ? "#DB18DB" : getColor(d); })
        .style("stroke", "#fff")
        .on('mouseover', function(d) {
          if (d.depth != null) text.text(d[DESCR_PRED][0].value);
          if (id(d) in t1_s1) showCrosswalks(sunburst_t1, t1_s1[id(d)]);
          if (id(d) in t2_s1) showCrosswalks(sunburst_t2, t2_s1[id(d)]);
        })
        .on('mouseout',  function(d) {
          text.text("");
          if (id(d) in t1_s1) hideCrosswalks(sunburst_t1, t1_s1[id(d)]);
          if (id(d) in t2_s1) hideCrosswalks(sunburst_t2, t2_s1[id(d)]);
        })
        .on('click', toggle(sunburst_s1))
        .each(stash);

      nodes = sunburst_t2.partition.children(children(sunburst_t2)).nodes(sunburst_t2.root);
      collapse(nodes[0], 1);
      sunburst_t2.partition.children(function(d){return d.children}).nodes(sunburst_t2.root);

      sunburst_t2.paths = svg3.selectAll("path").data(nodes, function(d) { return d.id || (d.id = ++i); });
      sunburst_t2.paths.enter().append("path")
        .attr("d", arc)
        .attr("display", function(d) { return d.depth == 0 || d.dx == 0 ? "none" : null; }) // hide inner ring
        .style("fill", function(d) { return id(d) in t2_s1 ? "#DB18DB" : getColor(d); })
        .style("stroke", "#fff")
        .on('mouseover', function(d) {
          if (d.depth != null) text.text(d[DESCR_PRED][0].value);
          if (id(d) in t2_s1) showCrosswalks(sunburst_s1, t2_s1[id(d)]);
        })
        .on('mouseout',  function(d) {
          text.text("");
          if (id(d) in t2_s1) hideCrosswalks(sunburst_s1, t2_s1[id(d)]);
        })
        .on('click', toggle(sunburst_t2))
        .each(stash);
    }

    // Helper functions ////////////////////////////////////////////////////////
    // minimizes all the nodes at the specified depth
    function collapse(tree, depth) {
      walkTree(tree, function(d) {
        if (d.depth == depth) {
          d._children = d.children;
          d.children  = null;
        }
        if (d.depth > depth) {
          d.dx = 0;
        }
      });
    }

    function id(d) { return d[ID_PRED] ? d[ID_PRED][0].value.slice(-8) : ""; }

    // specifies how to retrieve children from the json
    function children(sunburst) {
      return function (d) {
        var children = [];
        if (d[CHILD_PRED]) {
          d[CHILD_PRED].forEach(function (x){children.push(sunburst.data[x.value]);});
        }
        return children;
      }
    }

    // applies a function to the entire tree
    function walkTree(d, f) {
      if (d.children)
        d.children.forEach(function (x) { walkTree(x, f); });
      f(d);
    }

    // setup for switching data: stash the old values for transition.
    function stash(d) {
      d.x0  = d.x;
      d.dx0 = d.dx;
      d.y0  = d.y;
      d.dy0 = d.dy;
    }

    // interpolate the arcs in data space for the transitions
    function arcTweenData(a, i) {
      var oi = d3.interpolate({x: a.x0, dx: a.dx0, y: a.y0, dy: a.dy0}, a);

      return function (t) {
        var b = oi(t);
        a.x0  = b.x;
        a.dx0 = b.dx;
        a.y0  = b.y;
        a.dy0 = b.dy;
        return arc(b);
      }
    }
  </script>
</body>
</html>
